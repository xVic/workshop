[[rest-bootstrapping]]
= Hero Microservice

:icons: font

First thing first, we need a project.
That's what your are going to see in this section.

== Bootstrapping the Hero REST Endpoint

The easiest way to create a new Quarkus project is to use the Quarkus Maven plugin.
We have created the project structure earlier, so we will move to the `super-heroes` directory and run the project creation command.
Open a terminal and run the following command:

icon:hand-o-right[role="red", size=2x] [red big]#Call to action#

[source,shell]
----
include::{github-raw}/super-heroes/rest-hero/bootstrap.sh[tag=adocSnippet]
----

== Directory Structure

Once you bootstrap the project, you get the following directory structure with a few Java classes and other artifacts :

[plantuml]
----
@startsalt
{
{
T
super-heroes
+  rest-hero
++  src
+++  main
++++  docker
+++++  Dockerfile.jvm
+++++  Dockerfile.legacy-jar
+++++  Dockerfile.native
+++++  Dockerfile.native-distroless
++++  java
+++++  io
++++++  quarkus
+++++++  workshop
++++++++  superheroes
+++++++++  hero
++++++++++  HeroResource.java
++++  resources
+++++  META-INF
++++++  resources
+++++++  index.html
+++++  application.properties
+++  test
++++  java
+++++  io
++++++  quarkus
+++++++  workshop
++++++++  superheroes
+++++++++  hero
++++++++++  HeroResourceTest.java
++++++++++  NativeHeroResourceIT.java
++  mvnw
++  mvnw.cmd
++  pom.xml
}
}
@endsalt
----

The Maven archetype generates the following `rest-hero` sub-directory:

* the Maven structure with a `pom.xml`
* an `io.quarkus.workshop.superheroes.hero.HeroResource` resource exposed on `/api/heroes`
* an associated unit test `HeroResourceTest`
* the landing page `index.html` that is accessible after starting the application
* example `Dockerfile` files for both native and jvm modes in `src/main/docker`
* the `application.properties` configuration file

Once generated, look at the `pom.xml`.
You will find the import of the Quarkus BOM, allowing you to omit the version on the different Quarkus dependencies.
In addition, you can see the `quarkus-maven-plugin` responsible of the packaging of the application and also providing the development mode.

[source,xml,indent=0]
----
include::{github-raw}/super-heroes/rest-hero/pom.xml[tags=adocProperties]
include::{github-raw}/super-heroes/rest-hero/pom.xml[tags=adocDependencyManagement]
include::{github-raw}/super-heroes/rest-hero/pom.xml[tags=adocBuild]
----

If we focus on the dependencies section, you can see the extension allowing the development of REST applications:

[source,xml,indent=0]
----
include::{github-raw}/super-heroes/rest-hero/pom.xml[tags=adocDependencyResteasy]
----

[TIP]
.RESTEasy
====
You may not be familiar with RESTEasy.footnote:[RESTEasy https://resteasy.github.io]
It's an implementation of JAX-RS and it uses to implement RestFul services in Quarkus.
====

[NOTE]
.What's this Quarkus bom thingy?
====
The Quarkus Universe includes Quarkus as well as third-party extensions, like Apache Camel.
====

== The JAX-RS Resource

During the project creation, the `HeroResource.java` file has been created with the following content:

[source]
----
package io.quarkus.workshop.superheroes.hero;

@Path("/api/heroes")
public class HeroResource {

    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public String hello() {
        return "hello";
    }
}
----

It's a very simple REST endpoint, returning "hello" to requests on `/api/heroes`.

== Running the Application

Now we are ready to run our application.

icon:hand-o-right[role="red", size=2x] [red big]#Call to action#

Use: `./mvnw quarkus:dev`:

[NOTE]
--
**IMPORTANT** copy the url mentioned in the CodeReady Workspace pop-up. The url should contain the port 8080 as we can see in the previous log. This url corresponds to the rest-hero microservice.
--

[source,shell]
----
$ ./mvnw quarkus:dev
[INFO] Scanning for projects...
[INFO]
[INFO] -------------< io.quarkus.workshop.super-heroes:rest-hero >-------------
[INFO] Building rest-hero 1.0-SNAPSHOT
[INFO] --------------------------------[ jar ]---------------------------------
[INFO]
[INFO] --- quarkus-maven-plugin:2.2.2.Final:dev (default-cli) @ rest-hero ---
[INFO] Using 'UTF-8' encoding to copy filtered resources.
[INFO] Copying 2 resources
[INFO] Nothing to compile - all classes are up to date
Listening for transport dt_socket at address: 5005
__  ____  __  _____   ___  __ ____  ______
 --/ __ \/ / / / _ | / _ \/ //_/ / / / __/
 -/ /_/ / /_/ / __ |/ , _/ ,< / /_/ /\ \
--\___\_\____/_/ |_/_/|_/_/|_|\____/___/
2020-11-16 10:01:51,331 INFO  [io.quarkus] (Quarkus Main Thread) rest-hero 1.0-SNAPSHOT on JVM (powered by Quarkus 2.2.2.Final) started in 3.797s. Listening on: http://0.0.0.0:8080
2020-11-16 10:01:51,343 INFO  [io.quarkus] (Quarkus Main Thread) Profile dev activated. Live Coding activated.
2020-11-16 10:01:51,343 INFO  [io.quarkus] (Quarkus Main Thread) Installed features: [cdi, resteasy]
----

Then check that the endpoint returns `hello` as expected:

[source,shell]Now we are ready to run our application
----
$ curl $URL/api/heroes
hello RESTEasy
----

Alternatively, you can open $URL/api/heroes in your browser.

[NOTE]
--
Change the url by the one you should have got from CRW
--

== Development Mode

`quarkus:dev` runs Quarkus in development mode.
This enables hot deployment with background compilation, which means that when you modify your Java files and/or your resource files and invoke a REST endpoint (i.e. cUrl command or refresh your browser), these changes will automatically take effect.
This works too for resource files like the configuration property and HTML files.
Refreshing the browser triggers a scan of the workspace, and if any changes are detected, the Java files are recompiled and the application is redeployed;
your request is then serviced by the redeployed application.
If there are any issues with compilation or deployment an error page will let you know.

The development mode also allows debugging and listens for a debugger on port 5005.
If you want to wait for the debugger to attach before running you can pass `-Dsuspend=true` on the command line.
If you don't want the debugger at all you can use `-Ddebug=false`.

Alright, time to change some code.
Open your favorite IDE and import the project.
To check that the hot reload is working, update the method `HeroResource.hello()` by returning the String "hello hero".
Now, execute the cUrl command again, the output has changed without you to having to stop and restart Quarkus:

icon:hand-o-right[role="red", size=2x] [red big]#Call to action#

[source,shell]
----
$ curl http://$(oc get route -n USERNAME-codeready | grep 8080 | awk '{ print $2 }')/api/heroes
hello hero
----

== Testing the Application

All right, so far so good, but wouldn't it be better with a few tests, just in case.

In the generated `pom.xml` file, you can see 2 test dependencies:

[source,xml,indent=0]
----
include::{github-raw}/super-heroes/rest-hero/pom.xml[tags=adocDependencyTest]
----

Quarkus supports Junit 4 and Junit 5 tests.
In the generated project, we use Junit 5.
Because of this, the version of the Surefire Maven Plugin must be set, as the default version does not support Junit 5:

[source,xml,indent=0]
----
include::{github-raw}/super-heroes/rest-hero/pom.xml[tags=adocBuildSurefire]
----

We also set the `java.util.logging` system property to make sure tests will use the correct log manager.

The generated project contains a simple test in `HeroResourceTest.java`.

[source]
----
package io.quarkus.workshop.superheroes.hero;

@QuarkusTest
public class HeroResourceTest {

    @Test
    public void testHelloEndpoint() {
        given()
          .when().get("/api/heroes")
          .then()
             .statusCode(200)
             .body(is("hello"));
    }
}
----

By using the `QuarkusTest` runner, the `HeroResourceTest` class instructs JUnit to start the application before the tests.
Then, the `testHelloEndpoint` method checks the HTTP response status code and content.
Notice that these tests use RestAssured, but feel free to use your favorite library.footnote:[RestAssured http://rest-assured.io]

icon:hand-o-right[role="red", size=2x] [red big]#Call to action#

Execute it with `./mvnw test` or from your IDE.
It fails! It's expected, you changed the output of `HeroResource.hello()` earlier.
Adjust the test body condition accordingly.

== Packaging and Running the Application

icon:hand-o-right[role="red", size=2x] [red big]#Call to action#

The application is packaged using `./mvnw package`.

It produces the `quarkus-run.jar` file in the `target/quarkus-app/` directory.
Be aware that it’s not an _über-jar_ as the dependencies are copied into the `target/quarkus-app/lib/` directory.

You can run the application using: `java -jar target/quarkus-app/quarkus-run.jar`.

[NOTE]
====
Before running the application, don't forget to stop the hot reload mode (hit CTRL+C), or you will have a port conflict.
====

== Troubleshooting

You might come across the following error while developing:

[source,shell]
----
WARN  [io.qu.ne.ru.NettyRecorder] (Thread-48) Localhost lookup took more than one second, you need to add a /etc/hosts entry to improve Quarkus startup time. See https://thoeni.io/post/macos-sierra-java/ for details.
----

If this is the case, it's just a matter to add the node name of your machine to the /etc/hosts.
For that, first get the name of your node with the following command:

[source,shell]
----
$ uname -n
my-node.local
----

Then `sudo vi /etc/hosts` so you have the rights to edit the file and add the following entry

[source,shell]
----
127.0.0.1 localhost my-node.local
----
